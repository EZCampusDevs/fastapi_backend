"""Schedule Optimization module.

VERY IMPORTANT NOTE: Optimization manifests use Course.class_type values to specify required course
"manifests". Technically the current logic would also work if all Course.class_type references were
replaced with Course.link_tag, however in some rare cases link_tag is not defaulted.

Notes:
    schedule or schedule_result: A list of courses defining a resulting schedule.

    initial_schedule: A list of Courses that make the base of a schedule to be built upon. Starts
        as a copy of required_courses because we assume the resulting schedule should include the
        required courses. This variable could technically be replaced by the original
        required_courses, but by using a second variable it improves readability and future logic.

    manifest: A list of strings. Each string represents an element that is required by the final
        resulting schedule. These string values are generated by __get_manifest_value().

        The manifest should not include strings representing courses specified as required_courses.
        Remember, the manifest is specifies what still needs to be fulfilled. required_courses will
        be added to initial_schedule and are already accounted for.

    options_2d: Individual Course and its rating as options in a tuple, stored in a list.

        Used for schedule build attempts as options are removed.

        options_2d is sorted <from index 0 to n> by 3 conditions:
            1.  End time calculation, early end represented by datetime.timedelta()
                <low/early to high/later>.
            2.  Length of time the first meeting runs <low/early to high/late>.
            3.  Rating <high to low>.

        The structure is as follows:
            1st D = List of options.
            2nd D = Tuple of (Course, Course's Evaluated rating).

            Examples:
                [
                    (YEET0000U_LAB_1, RATING),
                    (YEET0000U_LAB_2, RATING),
                    (YEET0000U_LECTURE_1, RATING),
                    (YEET0000U_LECTURE_2, RATING),
                    (BORK0001U_LECTURE_1, RATING),
                    (BORK0001U_LECTURE_2, RATING),
                        ...
                ]

    options_3d: Individual Course and its rating as options for a schedule in a tuple, stored in a
        sublist, stored in a main list. The sublist are organized options according to manifest
        specifications.

        Used for distributed lowest rated options removal. As options are removed, elements are
        actually removed from the sub lists of options_3d.

        options_3d is sorted <from index 0 to n> by 1 condition:
            1.  Number of options per sublist <low to high>.
        Each options_3d's sublist is sorted <from index 0 to n> by 1 condition:
            1.  Rating <high to low>.

        The structure is as follows:
            1st D = List of options organized by manifest requirements.
            2nd D = List of singular manifest requirement options, in other words, this list
                    describes all options that can fulfill a given manifest requirement "x".
            3rd D = Tuple of (Course, Course's Evaluated rating). Format is same as where this
                    function is called.

            Examples:
                [
                    [
                        (YEET0000U_LAB_1, RATING),
                        (YEET0000U_LAB_2, RATING),
                            ...
                    ],
                    [
                        (YEET0000U_LECTURE_1, RATING),
                        (YEET0000U_LECTURE_2, RATING),
                            ...
                    ],
                    [
                        (BORK0001U_LECTURE_1, RATING),
                        (BORK0001U_LECTURE_2, RATING),
                            ...
                    ],
                        ...
                ]
"""

import math
from datetime import time, date, datetime, timedelta
from itertools import chain

from fastapi import HTTPException, status

from py_core.classes.course_class import Course, schedule_time_conflicts
from py_core.classes.optimizer_criteria_class import CourseOptimizerCriteria

# HTTPExceptions
API_404_OPEN_SEATS_CONFLICT = HTTPException(
    status_code=status.HTTP_404_NOT_FOUND,
    detail="All requested courses' seats are full.",
)
API_404_RESTRICTION_CONFLICT = HTTPException(
    status_code=status.HTTP_404_NOT_FOUND,
    detail="Course restrictions prevent all options.",
)
API_404_IMPOSSIBLE_BUILD = HTTPException(
    status_code=status.HTTP_404_NOT_FOUND,
    detail="Program could not create a valid schedule. Likely reason(s): "
    "restrictions, seating, time conflicts.",
)


def API_400_REQUIRED_COURSES_CONFLICT(required_courses: list[Course]) -> HTTPException:
    return HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST,
        detail=f"Required courses {required_courses} are time conflicting.",
    )


MAX_OPTIMIZATION_ATTEMPTS = 10  # Optimizer constants.

# Restrictions langauge processing, The following condition string(s) is/are hardcoded (obviously)
# and based of previous understood example(s).
# TODO(Daniel): Hardcoded assumption code:
SINGULAR_CONDITION = "one of"


def course_level_optimizer(
    options: list[Course],
    criteria: CourseOptimizerCriteria,
    required_courses: list[Course] = None,
    ensure_open_seats: bool = False,
    ensure_restrictions_met: bool = False,
    restrictions_met: dict = None,
) -> (list[Course] | None, float):
    """Course level optimizer algorithm.

    Args:
        options: Individual Course as options for a schedule in a single list.
        criteria: CourseOptimizerCriteria describes the options criteria.
        required_courses: Optional condition, list of Courses that must be in the final schedule.
        ensure_open_seats: Optional condition, if ensure_open_seats is True, schedule will only
            build if courses have a minimum of 1 seat open, default is False.
        ensure_restrictions_met: Optional condition, if ensure_restrictions_met is True, schedule
            will only build if courses have all their restrictions met, default is False.
        restrictions_met: Optional condition, Dictionary of course restrictions met by the user.

    Notes:
        Courses in required_courses is the initial_schedule and thus overrules ensure_open_seats.
        This is a useful feature for when a student is registered for certain classes that are
        full, however they want to register for more courses.

    Returns:
        List of Course objects of the optimized schedule, None if no schedule was time valid.
        Confidence float value.
        Possible combinations count int value.
    """
    # ---------- Start of initial data checks ----------
    if required_courses is None:  # No required Courses specified.
        required_courses = []
    elif schedule_time_conflicts(course_list=required_courses):
        # Ensure specified Courses are not time conflicting.
        raise API_400_REQUIRED_COURSES_CONFLICT(required_courses)

    initial_schedule = required_courses.copy()
    # Initial schedule can now be set and its fulfilled manifest values.
    fulfilled_manifest = [c.get_comp_key() for c in required_courses]
    # fulfilled_manifest specifies what has already been fulfilled.

    if not options:  # Empty options list.
        return initial_schedule, 1.0, 1
    if ensure_open_seats:
        # Remove all options with no open seats.
        options = [c for c in options if c.seats_available > 0]
        if not options:  # Empty options list.
            raise API_404_OPEN_SEATS_CONFLICT
    if ensure_restrictions_met and restrictions_met is not None:
        # ensure_restrictions_met is True, and restrictions_met is set.
        # Remove all options that have unmet restrictions.
        options = [
            c
            for c in options
            if __all_restrictions_met(restrictions_met=restrictions_met, course=c)
        ]
        if not options:  # Empty options list.
            raise API_404_RESTRICTION_CONFLICT
    # ---------- End of initial data checks ----------

    # ---------- Start of schedule manifest generation ----------
    manifest = []
    for course in options:
        if (
            course.get_comp_key() not in fulfilled_manifest
            and course.get_comp_key() not in manifest
        ):
            manifest.append(course.get_comp_key())
    del fulfilled_manifest  # Delete fulfilled_manifest to prevent mistaken references.
    # ---------- End of schedule manifest generation ----------

    # ---------- Start of options 2D generation ----------
    options_2d = [(course, criteria.course_eval(course)) for course in options]
    # ---------- End of options 2D generation ----------

    # ---------- Start of check first initial build with all options ----------
    # We check if a valid schedule can be built with zero options removed. This is a redundant
    # check done first so that unnecessary calculations are not completed trying to build a
    # schedule which is physically impossible.
    # Note: Underscores are used to differentiate from build attempts with option removal.
    _options_3d = __remove_n_options(
        manifest=manifest, n=0, options_2d=options_2d, options_3d=None
    )
    _options_2d = list(chain.from_iterable(_options_3d))
    # Recreate options_2d from options_3d by reshaping to 2D.
    _result = __attempt_build(
        options_2d=options_2d, initial_schedule=initial_schedule, manifest=manifest
    )

    if _result is None:
        raise API_404_IMPOSSIBLE_BUILD
    schedule_result = _result  # schedule_result is initialized here.
    possible_combos = 1  # Total number of possible schedule combinations.
    if _options_3d is not None:
        # Calculate maximum possible combinations at the first build attempt with no removal.
        for sub_list in _options_3d:
            possible_combos *= len(sub_list)
    del _options_3d, _options_2d, _result
    # Delete in prep for option removal build attempts.
    # ---------- End of check first initial build with all options ----------

    # ---------- Start of build attempts with option removal ----------
    # Check if option removal is even needed:
    all_ratings = [rating for _, rating in options_2d]

    if len(set(all_ratings)) == 1 and all_ratings[0] == 0:  # All ratings = 0,
        # option removal is not needed, only run zero removal build attempt.
        removal_count_limit = 1
        # In this case these values don't really matter, but should be equal to each other in order
        # to halt right after the first attempt.

        # Technically a local variable with int value of 1 can replace MAX_OPTIMIZATION_ATTEMPTS to
        # stop the for loop (below), instead of hard coding these 2 values. It would be more
        # efficient and readable since zero removals would be executed by the for loop. However, I
        # think it would complicate the logic that I've already written, but more importantly this
        # is for handling a rare edge case. The point of the course_level_optimizer is to evaluate
        # courses. I don't want to complicate the currently streamlined code for someone who sent a
        # bad request/parameter. - Daniel
    else:
        removal_count_limit = len(options) - len(manifest)
    # These variables are used in the halving algorithm to find the optimization point the quickest.
    proven_min_index = 0
    checking_max_index = removal_count_limit - 1
    remove_count = 0

    for attempt_index in range(MAX_OPTIMIZATION_ATTEMPTS):
        half_index = __half(proven_min_index, checking_max_index)  # Get the half point.
        remove_count = half_index + 1

        options_3d = __remove_n_options(
            manifest=manifest, n=remove_count, options_2d=options_2d, options_3d=None
        )  # Remove n options.
        options_2d_temp = list(
            chain.from_iterable(options_3d)
        )  # Reshape options_3d to 2D.
        result = __attempt_build(
            options_2d=options_2d_temp,
            initial_schedule=initial_schedule,
            manifest=manifest,
        )  # Attempt a build with the new half point + 1 options removed.

        if result is not None:
            schedule_result = result  # Update to the new valid schedule.
            proven_min_index = half_index  # checking_max_index = SAME_AS_BEFORE.
        else:
            # proven_min_index = SAME_AS_BEFORE.
            checking_max_index = half_index - 1
        if proven_min_index == checking_max_index:  # Reached full optimization.
            break
    # ---------- End of build attempts with option removal ----------

    # ---------- Start of result processing ----------
    confidence = remove_count / removal_count_limit
    # confidence = total number of options removed / removal_count_limit.
    # Confidence is currently calculated as how close maximum we could optimize the schedule. The
    # best optimization case scenario would mean that options_left = length_of_the_manifest (and
    # obviously a successful schedule build). This is logically equal to the equation above. This
    # means that n / n = 1 and thus represents a 100% confidence.

    if schedule_result is None:
        return None

    # Sort the result by a string, this is done mainly for QOL. The return will all have the same
    # order and the data is easier for users to understand.
    schedule_result.sort(key=lambda c: f"{c.course_code} {c.class_type}")
    # ---------- End of result processing ----------
    ex_mts = []
    for c in schedule_result:
        ex_mts += c.class_time

    return {
        "schedule": ex_mts,
        "confidence": confidence,
        "possible_combinations": possible_combos,
        "simplified_manifest": [
            f"{c.course_code} {c.class_type}" for c in schedule_result
        ],
        "crns": [c.crn for c in schedule_result],
    }


def __attempt_build(
    options_2d: list[tuple[Course, float]],
    initial_schedule: list[Course],
    manifest: list[str],
) -> list[Course] | None:
    """Attempt to build a schedule around an initial_course pick.

    Args:
        options_2d: See this module's docstring.
        initial_schedule: See this module's docstring.
        manifest: See this module's docstring.

    Returns:
        A valid schedule (list[Course]) or None in the case a schedule was not
        possible given the initial_course.
    """
    # Copy initial lists.
    schedule = initial_schedule.copy()
    remaining_manifest = manifest.copy()
    # Sort options_2d (sorting explanation on this module's docstring).
    options_2d.sort(
        key=lambda sub_tuple: (
            __end_time_calculation(course=sub_tuple[0]),
            __first_meeting_length(course_obj=sub_tuple[0]),
            sub_tuple[1],
        ),
        reverse=True,
    )
    # 1. End time calculation <low/early to high/later>.
    # 2. Length of time the first meeting runs <low/early to high/later>.
    # 3. Rating <high to low>.

    # Build a schedule.
    for course, _ in options_2d:  # Loop through all options.
        if course.get_comp_key() in remaining_manifest and not schedule_time_conflicts(
            schedule + [course]
        ):
            # Check if the Course's manifest representative value is still listed (as needed) on
            # the manifest and check for schedule time validation.
            schedule.append(course)
            remaining_manifest.remove(course.get_comp_key())
        if len(remaining_manifest) == 0 and not schedule_time_conflicts(schedule):
            return schedule
    return None  # A time valid schedule is not possible.


def __end_time_calculation(course: Course) -> timedelta:
    """Get a course's first meeting time end to a time delta for easy sort key value calculation.

    Args:
        course: Course object to get end time timedelta of.

    Returns:
        The difference between the first meeting start and end times as datetime.timedelta(),
        timedelta(0) if meetings do not exist.
    """
    if course.class_time is None or not course.class_time:  # None or empty class time.
        return timedelta(0)
    return datetime.combine(date.min, time.max) - datetime.combine(
        date.min, course.class_time[0].time_end
    )


def __first_meeting_length(course_obj: Course) -> timedelta:
    """Length of time a course's first meeting runs for.

    Args:
        course_obj:

    Returns:
        The difference between the first meeting start and end times as datetime.timedelta(),
        timedelta(0) if meetings do not exist.
    """
    if course_obj.class_time is None or not course_obj.class_time:
        # None or empty class time.
        return timedelta(0)
    return abs(
        datetime.combine(date.min, course_obj.class_time[0].time_end)
        - datetime.combine(date.min, course_obj.class_time[0].time_start)
    )


def __remove_n_options(
    manifest: list[str],
    n: int,
    options_2d: list[tuple[Course, float]] = None,
    options_3d: list[list[tuple[Course, float]]] = None,
) -> list[list[tuple[Course, float]]]:
    """Remove "n" the lowest rated courses distributed by manifest requirements.

    Args:
        options_2d: See this module's docstring.
        options_3d: See this module's docstring.
        n: n (int) number of courses to remove by lowest ratings.

    Returns:
        options_3d with lowest "n" ratings removed distributively.

    Raises:
        ValueError: At least one of options_2d and options_3d must be specified.
    """
    if n < 0:
        raise ValueError(f"Expected n > 0, got n={n}")
    if options_2d is None and options_3d is None:
        raise ValueError("At least one of options_2d and options_3d must be specified.")

    if options_2d is not None and options_3d is None:
        # Options_2d is given, but not options_3d, generate a 3d version.
        options_3d = [[] for _ in manifest]
        for course, rating in options_2d:
            if course.get_comp_key() in manifest:
                # This if statement ensures that the course is still required. In other words the
                # current Course object being checked is not already fulfilled by the manifest.
                # Without this if statement there is a possibility that .index() will ValueError.
                # This will occur when the Course object being checked matches the
                # __get_manifest_value() of a Course object which was specified through
                # required_crn. Basically we skip courses already specified by the required_crns
                # since we already saved it into the initial schedule.
                options_3d[manifest.index(course.get_comp_key())].append(
                    (course, rating)
                )
        # Sort options_3d (sorting explanation on this module's docstring).
        # Sorting is done only on initialization.
        options_3d.sort(key=lambda option_sub_list: len(option_sub_list))
        # 1. Options per sublist <low to high>.
        for sub_list in options_3d:
            sub_list.sort(key=lambda sub_tuple: (sub_tuple[1]), reverse=True)
            # 1. Rating <high to low>.
    # Remove "n" the lowest rated courses distributed by manifest requirements.
    lengths = __distributed_lengths(options_3d=options_3d, n=n)  # Get lengths.
    options_3d = [sub_list[: lengths[i]] for (i, sub_list) in enumerate(options_3d)]
    # Apply new lengths.
    return options_3d


def __distributed_lengths(
    options_3d: list[list[tuple[Course, float]]], n: int
) -> list[int]:
    """Calculate (distributed) lengths of each sublist on options_3d.

    Notes:
        This is the main logic that handels distributive option removal.

    Args:
        options_3d: See this module's docstring.
        n: n (int) number of options (courses) to remove (by lowest ratings).

    Returns:
        List of lengths of each sublist on options_3d after removing n elements.

    Examples: (These examples are of incorrect param type, but work as examples)
        >>> __distributed_lengths(options_3d=[[1], [3, 3, 3], [3, 3, 3], [5, 5, 5, 5, 5]], n=0)
        [1, 3, 3, 5]
        >>> __distributed_lengths(options_3d=[[1], [3, 3, 3], [3, 3, 3], [5, 5, 5, 5, 5]], n=1)
        [1, 3, 3, 4]
        >>> __distributed_lengths(options_3d=[[1], [3, 3, 3], [3, 3, 3], [5, 5, 5, 5, 5]], n=2)
        [1, 3, 3, 3]
        >>> __distributed_lengths(options_3d=[[1], [3, 3, 3], [3, 3, 3], [5, 5, 5, 5, 5]], n=3)
        [1, 2, 3, 3]
        >>> __distributed_lengths(options_3d=[[1], [3, 3, 3], [3, 3, 3], [5, 5, 5, 5, 5]], n=4)
        [1, 2, 2, 3]
        >>> __distributed_lengths(options_3d=[[1], [3, 3, 3], [3, 3, 3], [5, 5, 5, 5, 5]], n=5)
        [1, 2, 2, 2]
        >>> __distributed_lengths(options_3d=[[1], [3, 3, 3], [3, 3, 3], [5, 5, 5, 5, 5]], n=99999)
        [1, 1, 1, 1]
    """
    if n < 0:
        raise ValueError(f"Expected n > 0, got n={n}")

    lengths = [len(sub_list) for sub_list in options_3d]
    remove_count_sum = 0
    reached_end = True
    while reached_end:
        for _ in range(len(options_3d)):
            if remove_count_sum == n or (len(set(lengths)) == 1 == lengths[0]):
                # Remove count cap reached or all elements in lengths have reached the minimum
                # value of 1.
                reached_end = False  # Declare to end while loop.
                break  # End for loop.
            # TODO(Daniel): TEMPORARY REDUNDANCY CODE vvv
            if remove_count_sum >= n:
                raise RuntimeError("FATAL OPTIMIZER ERROR: remove_count_sum >= n")
            # TODO(Daniel): TEMPORARY REDUNDANCY CODE ^^^
            count = 0
            max_length = lengths[-1]
            i_remove = lengths.index(max_length)
            # Index to remove options (reduce lengths).
            if lengths[i_remove] > 1:
                # All elements in lengths must have the minimum value of 1.
                if i_remove > 0:  # Backwards length value check is required.
                    if (
                        i_remove < len(lengths) - 1
                        and lengths[i_remove] == lengths[i_remove + 1]
                    ):
                        # Forwards length value check is required and passed.
                        count = 1  # Forwards length value is tied, remove 1.
                    else:
                        count = lengths[i_remove] - lengths[i_remove - 1]
                        # Calculate remove value as difference between current length value and 1
                        # index backwards.
                else:
                    count = 1  # No backwards length value check, auto remove 1.
            # Remove count cap reached checks.
            if count > n:
                count = n
            elif remove_count_sum + count > n:
                count = (remove_count_sum + count) - n
            # Update with new counts value.
            lengths[i_remove] -= count
            remove_count_sum += count
    return lengths


def __half(min_limit: int, max_limit: int) -> int:
    """Returns the next number in a halving algorithm.

    Args:
        min_limit: Minimum possible index to check.
        max_limit: Maximum possible index to check.

    Returns:
        Returns the next number in a halving algorthm.

    Examples:
        >>> __half(min_limit=2, max_limit=3)
        3
        >>> __half(min_limit=2, max_limit=3)
        3
        >>> __half(min_limit=3, max_limit=3)
        3
        >>> __half(min_limit=3, max_limit=3)
        3
        >>> __half(min_limit=0, max_limit=3)
        2
        >>> __half(min_limit=0, max_limit=3)
        2
        >>> __half(min_limit=11, max_limit=12)
        12
        >>> __half(min_limit=0, max_limit=9)
        5
        >>> __half(min_limit=5, max_limit=9)
        7
        >>> __half(min_limit=5, max_limit=7)
        6
        >>> __half(min_limit=5, max_limit=6)
        6
    """
    assert min_limit <= max_limit, "Expected min_limit <= max_limit"
    return math.ceil(min_limit + ((max_limit - min_limit) / 2))


def __all_restrictions_met(restrictions_met: dict, course: Course) -> bool:
    """Check if a restrictions given meet the restrictions of a Course.

    Args:
        restrictions_met: Restrictions currently met.
        course: Course object to check restrictions of.

    Returns:
        True of all restrictions are met, False if not met.
    """
    if not isinstance(restrictions_met, dict):
        raise TypeError(
            f"restrictions_met expected {dict}, received {type(restrictions_met)}"
        )

    for r_type, r_list in course.restrictions.items():
        # We are checking for 1) the type of restriction and 2) the count of restriction
        # condition(s) (singular vs all) needed to be met.
        if r_type in restrictions_met.keys():  # Check for matching type.
            if SINGULAR_CONDITION.lower() in r_type.lower():
                # Ensure a singular condition.
                passed_singular_check = False
                for r_value_detail in r_list:
                    # Check that the course's current r_list being checked has a match with at
                    # least one of the user's specified met restrictions for that specific type of
                    # restriction.
                    if r_value_detail in restrictions_met[r_type]:
                        passed_singular_check = True
                        break
                if not passed_singular_check:
                    return False
            elif not set(r_list).issubset(set(restrictions_met[r_type])):
                # Ensure all conditions. Check that the course's current r_list being checked is a
                # subset of the user's specified met restrictions for that specific type of
                # restriction.
                return False
        else:  # Matching type not found.
            return False
    return True
